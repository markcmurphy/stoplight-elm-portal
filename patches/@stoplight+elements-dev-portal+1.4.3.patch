diff --git a/node_modules/@stoplight/elements-dev-portal/index.mjs b/node_modules/@stoplight/elements-dev-portal/index.mjs
index 14d5178..f5c0e1e 100644
--- a/node_modules/@stoplight/elements-dev-portal/index.mjs
+++ b/node_modules/@stoplight/elements-dev-portal/index.mjs
@@ -1,125 +1,349 @@
-import { Menu, FieldButton, Provider, Modal, Input, Box, Icon, ListBox, ListBoxItem, Flex, VStack, Heading } from '@stoplight/mosaic';
+import {
+  Menu,
+  FieldButton,
+  Provider,
+  Modal,
+  Input,
+  Box,
+  Icon,
+  ListBox,
+  ListBoxItem,
+  Flex,
+  VStack,
+  Heading,
+} from '@stoplight/mosaic';
 import * as React from 'react';
 import React__default from 'react';
-import { withQueryClientProvider, PersistenceContextProvider, MarkdownComponentsProvider, MockingProvider, Docs, withStyles, withPersistenceBoundary, withMosaicProvider, NodeTypeIconDefs, NodeTypeColors, TableOfContents as TableOfContents$1, PoweredByLink, useRouter, findFirstNode, SidebarLayout } from '@stoplight/elements-core';
+import {
+  withQueryClientProvider,
+  PersistenceContextProvider,
+  MarkdownComponentsProvider,
+  MockingProvider,
+  Docs,
+  withStyles,
+  withPersistenceBoundary,
+  withMosaicProvider,
+  NodeTypeIconDefs,
+  NodeTypeColors,
+  TableOfContents as TableOfContents$1,
+  PoweredByLink,
+  useRouter,
+  findFirstNode,
+  SidebarLayout,
+} from '@stoplight/elements-core';
 import { resolve, dirname } from '@stoplight/path';
 import { NodeType } from '@stoplight/types';
 import { faSearch } from '@fortawesome/free-solid-svg-icons/faSearch';
 import { pipe } from 'lodash/fp';
 import { Route, useParams, useHistory, Redirect, Link } from 'react-router-dom';
-import { faCircleNotch, faExclamationTriangle } from '@fortawesome/free-solid-svg-icons';
-import { useQuery } from 'react-query';
+import {
+  faCircleNotch,
+  faExclamationTriangle,
+} from '@fortawesome/free-solid-svg-icons';
+import { useQuery, useQueries } from 'react-query';
 import { useDebounce } from 'use-debounce';
 
 const BranchSelector = ({ branchSlug, branches, onChange }) => {
-    const currentBranch = branches.find(branch => (!branchSlug ? branch.is_default : branch.slug === branchSlug));
-    const handleChange = React.useCallback((selectedSlug) => {
-        const selectedBranch = branches.find(branch => branch.slug === selectedSlug);
-        if (selectedBranch) {
-            onChange(selectedBranch);
-        }
-    }, [onChange, branches]);
-    return (React.createElement(Menu, { "aria-label": "Versions", placement: "bottom left", closeOnPress: true, matchTriggerWidth: true, renderTrigger: ({ isOpen }) => (React.createElement(FieldButton, { w: "full", icon: "layer-group", px: 4, h: "md", active: isOpen, borderR: 0, roundedR: "none" }, (currentBranch === null || currentBranch === void 0 ? void 0 : currentBranch.name) || (currentBranch === null || currentBranch === void 0 ? void 0 : currentBranch.slug) || 'Choose a version')), items: [
-            {
-                type: 'option_group',
-                title: 'Versions',
-                onChange: handleChange,
-                value: (currentBranch === null || currentBranch === void 0 ? void 0 : currentBranch.slug) || '',
-                children: branches.map(branch => ({
-                    label: branch.name || branch.slug,
-                    value: branch.slug,
-                    meta: branch.is_default ? 'Default' : undefined,
-                })),
-            },
-        ] }));
+  const currentBranch = branches.find((branch) =>
+    !branchSlug ? branch.is_default : branch.slug === branchSlug
+  );
+  const handleChange = React.useCallback(
+    (selectedSlug) => {
+      const selectedBranch = branches.find(
+        (branch) => branch.slug === selectedSlug
+      );
+      if (selectedBranch) {
+        onChange(selectedBranch);
+      }
+    },
+    [onChange, branches]
+  );
+  return React.createElement(Menu, {
+    'aria-label': 'Versions',
+    placement: 'bottom left',
+    closeOnPress: true,
+    matchTriggerWidth: true,
+    renderTrigger: ({ isOpen }) =>
+      React.createElement(
+        FieldButton,
+        {
+          w: 'full',
+          icon: 'layer-group',
+          px: 4,
+          h: 'md',
+          active: isOpen,
+          borderR: 0,
+          roundedR: 'none',
+        },
+        (currentBranch === null || currentBranch === void 0
+          ? void 0
+          : currentBranch.name) ||
+          (currentBranch === null || currentBranch === void 0
+            ? void 0
+            : currentBranch.slug) ||
+          'Choose a version'
+      ),
+    items: [
+      {
+        type: 'option_group',
+        title: 'Versions',
+        onChange: handleChange,
+        value:
+          (currentBranch === null || currentBranch === void 0
+            ? void 0
+            : currentBranch.slug) || '',
+        children: branches.map((branch) => ({
+          label: branch.name || branch.slug,
+          value: branch.slug,
+          meta: branch.is_default ? 'Default' : undefined,
+        })),
+      },
+    ],
+  });
 };
 
-const PlatformContext = React.createContext({ platformUrl: 'https://stoplight.io' });
-const PlatformProvider = ({ platformUrl = 'https://stoplight.io', platformAuthToken, children, }) => {
-    return (React.createElement(PlatformContext.Provider, { value: { platformUrl, platformAuthToken } },
-        React.createElement(Provider, null, children)));
+const PlatformContext = React.createContext({
+  platformUrl: 'https://stoplight.io',
+});
+const PlatformProvider = ({
+  platformUrl = 'https://stoplight.io',
+  platformAuthToken,
+  children,
+}) => {
+  return React.createElement(
+    PlatformContext.Provider,
+    { value: { platformUrl, platformAuthToken } },
+    React.createElement(Provider, null, children)
+  );
 };
 const DevPortalProvider = withQueryClientProvider(PlatformProvider);
 
-const NodeContent = ({ node, Link, hideTryIt, hideTryItPanel, hideMocking, hideExport, tryItCredentialsPolicy, tryItCorsProxy, }) => {
-    return (React.createElement(PersistenceContextProvider, null,
-        React.createElement(NodeLinkContext.Provider, { value: [node, Link] },
-            React.createElement(MarkdownComponentsProvider, { value: { a: LinkComponent } },
-                React.createElement(MockingProvider, { mockUrl: node.links.mock_url, hideMocking: hideMocking },
-                    React.createElement(Docs, { nodeType: node.type, nodeData: node.data, nodeTitle: node.title, layoutOptions: {
-                            hideTryIt: hideTryIt,
-                            hideTryItPanel: hideTryItPanel,
-                            hideExport: hideExport || node.links.export_url === undefined,
-                        }, useNodeForRefResolving: true, tryItCorsProxy: tryItCorsProxy, exportProps: [NodeType.HttpService, NodeType.Model].includes(node.type)
-                            ? {
-                                original: {
-                                    href: node.links.export_url,
-                                },
-                                bundled: {
-                                    href: getBundledUrl(node.links.export_url),
-                                },
-                            }
-                            : undefined, tryItCredentialsPolicy: tryItCredentialsPolicy }))))));
+const NodeContent = ({
+  node,
+  Link,
+  hideTryIt,
+  hideTryItPanel,
+  hideMocking,
+  hideExport,
+  tryItCredentialsPolicy,
+  tryItCorsProxy,
+}) => {
+  return React.createElement(
+    PersistenceContextProvider,
+    null,
+    React.createElement(
+      NodeLinkContext.Provider,
+      { value: [node, Link] },
+      React.createElement(
+        MarkdownComponentsProvider,
+        { value: { a: LinkComponent } },
+        React.createElement(
+          MockingProvider,
+          { mockUrl: node.links.mock_url, hideMocking: hideMocking },
+          React.createElement(Docs, {
+            nodeType: node.type,
+            nodeData: node.data,
+            nodeTitle: node.title,
+            layoutOptions: {
+              hideTryIt: hideTryIt,
+              hideTryItPanel: hideTryItPanel,
+              hideExport: hideExport || node.links.export_url === undefined,
+            },
+            useNodeForRefResolving: true,
+            tryItCorsProxy: tryItCorsProxy,
+            exportProps: [NodeType.HttpService, NodeType.Model].includes(
+              node.type
+            )
+              ? {
+                  original: {
+                    href: node.links.export_url,
+                  },
+                  bundled: {
+                    href: getBundledUrl(node.links.export_url),
+                  },
+                }
+              : undefined,
+            tryItCredentialsPolicy: tryItCredentialsPolicy,
+          })
+        )
+      )
+    )
+  );
 };
 const NodeLinkContext = React.createContext(undefined);
 const externalRegex = new RegExp('^(?:[a-z]+:)?//', 'i');
 const LinkComponent = ({ children, href }) => {
-    const ctx = React.useContext(NodeLinkContext);
-    if (href && externalRegex.test(href)) {
-        return (React.createElement("a", { href: href, target: "_blank", rel: "noreferrer" }, children));
-    }
-    if (href && ctx) {
-        const [node, Link] = ctx;
-        const resolvedUri = resolve(dirname(node.uri), href);
-        const [resolvedUriWithoutAnchor, hash] = resolvedUri.split('#');
-        const decodedUrl = decodeURIComponent(href);
-        const decodedResolvedUriWithoutAnchor = decodeURIComponent(resolvedUriWithoutAnchor);
-        const edge = node.outbound_edges.find(edge => edge.uri === decodedUrl || edge.uri === decodedResolvedUriWithoutAnchor);
-        if (edge) {
-            return (React.createElement(Link, { to: edge.slug, hash: hash }, children));
-        }
+  const ctx = React.useContext(NodeLinkContext);
+  if (href && externalRegex.test(href)) {
+    return React.createElement(
+      'a',
+      { href: href, target: '_blank', rel: 'noreferrer' },
+      children
+    );
+  }
+  if (href && ctx) {
+    const [node, Link] = ctx;
+    const resolvedUri = resolve(dirname(node.uri), href);
+    const [resolvedUriWithoutAnchor, hash] = resolvedUri.split('#');
+    const decodedUrl = decodeURIComponent(href);
+    const decodedResolvedUriWithoutAnchor = decodeURIComponent(
+      resolvedUriWithoutAnchor
+    );
+    const edge = node.outbound_edges.find(
+      (edge) =>
+        edge.uri === decodedUrl || edge.uri === decodedResolvedUriWithoutAnchor
+    );
+    if (edge) {
+      return React.createElement(Link, { to: edge.slug, hash: hash }, children);
     }
-    return React.createElement("a", { href: href }, children);
+  }
+  return React.createElement('a', { href: href }, children);
 };
 function getBundledUrl(url) {
-    if (url === undefined)
-        return undefined;
-    const bundledUrl = new URL(url);
-    const searchParams = new URLSearchParams(bundledUrl.search);
-    searchParams.append('deref', 'optimizedBundle');
-    bundledUrl.search = searchParams.toString();
-    return bundledUrl.toString();
+  if (url === undefined) return undefined;
+  const bundledUrl = new URL(url);
+  const searchParams = new URLSearchParams(bundledUrl.search);
+  searchParams.append('deref', 'optimizedBundle');
+  bundledUrl.search = searchParams.toString();
+  return bundledUrl.toString();
 }
 
-const SearchImpl = ({ search, searchResults, isOpen, onClose, onClick, onSearch }) => {
-    const listBoxRef = React.useRef(null);
-    const onChange = React.useCallback(e => onSearch(e.currentTarget.value), [onSearch]);
-    const onKeyDown = React.useCallback(e => {
-        var _a;
-        if (e.key === 'ArrowDown') {
-            e.preventDefault();
-            (_a = listBoxRef.current) === null || _a === void 0 ? void 0 : _a.focus();
-        }
-    }, []);
-    const onSelectionChange = React.useCallback(keys => {
-        const selectedId = keys.values().next().value;
-        const selectedResult = searchResults === null || searchResults === void 0 ? void 0 : searchResults.find(searchResult => `${searchResult.id}-${searchResult.project_id}` === selectedId);
-        if (selectedResult) {
-            onClick(selectedResult);
-        }
-    }, [searchResults, onClick]);
-    return (React.createElement(Modal, { renderHeader: () => (React.createElement(Input, { appearance: "minimal", borderB: true, size: "lg", icon: React.createElement(Box, { as: Icon, ml: 1, icon: faSearch }), autoFocus: true, placeholder: "Search...", value: search, onChange: onChange, onKeyDown: onKeyDown })), isOpen: !!isOpen, onClose: onClose }, searchResults && searchResults.length > 0 ? (React.createElement(ListBox, { ref: listBoxRef, "aria-label": "Search", overflowY: "auto", h: 80, m: -5, items: searchResults, selectionMode: "single", onSelectionChange: onSelectionChange }, (searchResult) => {
-        var _a, _b;
-        return (React.createElement(ListBoxItem, { key: `${searchResult.id}-${searchResult.project_id}`, textValue: searchResult.title },
-            React.createElement(Box, { p: 3, borderB: true },
-                React.createElement(Flex, { align: "center" },
-                    React.createElement(Box, { as: Icon, w: 4, icon: NodeTypeIconDefs[searchResult.type], style: { color: NodeTypeColors[searchResult.type] } }),
-                    React.createElement(Box, { flex: 1, fontSize: "lg", dangerouslySetInnerHTML: { __html: (_a = searchResult.highlighted.name) !== null && _a !== void 0 ? _a : '' }, fontWeight: "medium", textOverflow: "overflow-ellipsis", mx: 2 }),
-                    React.createElement(Box, { fontSize: "sm", color: "muted" }, searchResult.project_name)),
-                React.createElement(Box, { dangerouslySetInnerHTML: { __html: (_b = searchResult.highlighted.summary) !== null && _b !== void 0 ? _b : '' }, color: "muted", fontSize: "sm", mt: 1, ml: 6 }))));
-    })) : (React.createElement(Flex, { w: "full", h: 80, align: "center", justify: "center", m: -5 }, "No search results"))));
+const SearchImpl = ({
+  search,
+  searchResults,
+  isOpen,
+  onClose,
+  onClick,
+  onSearch,
+}) => {
+  const listBoxRef = React.useRef(null);
+  const onChange = React.useCallback((e) => onSearch(e.currentTarget.value), [
+    onSearch,
+  ]);
+  const onKeyDown = React.useCallback((e) => {
+    var _a;
+    if (e.key === 'ArrowDown') {
+      e.preventDefault();
+      (_a = listBoxRef.current) === null || _a === void 0 ? void 0 : _a.focus();
+    }
+  }, []);
+  const onSelectionChange = React.useCallback(
+    (keys) => {
+      const selectedId = keys.values().next().value;
+      const selectedResult =
+        searchResults === null || searchResults === void 0
+          ? void 0
+          : searchResults.find(
+              (searchResult) =>
+                `${searchResult.id}-${searchResult.project_id}` === selectedId
+            );
+      if (selectedResult) {
+        onClick(selectedResult);
+      }
+    },
+    [searchResults, onClick]
+  );
+  return React.createElement(
+    Modal,
+    {
+      renderHeader: () =>
+        React.createElement(Input, {
+          appearance: 'minimal',
+          borderB: true,
+          size: 'lg',
+          icon: React.createElement(Box, { as: Icon, ml: 1, icon: faSearch }),
+          autoFocus: true,
+          placeholder: 'Search...',
+          value: search,
+          onChange: onChange,
+          onKeyDown: onKeyDown,
+        }),
+      isOpen: !!isOpen,
+      onClose: onClose,
+    },
+    searchResults && searchResults.length > 0
+      ? React.createElement(
+          ListBox,
+          {
+            ref: listBoxRef,
+            'aria-label': 'Search',
+            overflowY: 'auto',
+            h: 80,
+            m: -5,
+            items: searchResults,
+            selectionMode: 'single',
+            onSelectionChange: onSelectionChange,
+          },
+          (searchResult) => {
+            var _a, _b;
+            return React.createElement(
+              ListBoxItem,
+              {
+                key: `${searchResult.id}-${searchResult.project_id}`,
+                textValue: searchResult.title,
+              },
+              React.createElement(
+                Box,
+                { p: 3, borderB: true },
+                React.createElement(
+                  Flex,
+                  { align: 'center' },
+                  React.createElement(Box, {
+                    as: Icon,
+                    w: 4,
+                    icon: NodeTypeIconDefs[searchResult.type],
+                    style: { color: NodeTypeColors[searchResult.type] },
+                  }),
+                  React.createElement(Box, {
+                    flex: 1,
+                    fontSize: 'lg',
+                    dangerouslySetInnerHTML: {
+                      __html:
+                        (_a = searchResult.highlighted.name) !== null &&
+                        _a !== void 0
+                          ? _a
+                          : '',
+                    },
+                    fontWeight: 'medium',
+                    textOverflow: 'overflow-ellipsis',
+                    mx: 2,
+                  }),
+                  React.createElement(
+                    Box,
+                    { fontSize: 'sm', color: 'muted' },
+                    searchResult.project_name
+                  )
+                ),
+                React.createElement(Box, {
+                  dangerouslySetInnerHTML: {
+                    __html:
+                      (_b = searchResult.highlighted.summary) !== null &&
+                      _b !== void 0
+                        ? _b
+                        : '',
+                  },
+                  color: 'muted',
+                  fontSize: 'sm',
+                  mt: 1,
+                  ml: 6,
+                })
+              )
+            );
+          }
+        )
+      : React.createElement(
+          Flex,
+          { w: 'full', h: 80, align: 'center', justify: 'center', m: -5 },
+          'No search results'
+        )
+  );
 };
-const Search = pipe(withStyles, withPersistenceBoundary, withMosaicProvider, withQueryClientProvider)(SearchImpl);
+const Search = pipe(
+  withStyles,
+  withPersistenceBoundary,
+  withMosaicProvider,
+  withQueryClientProvider
+)(SearchImpl);
 
 /*! *****************************************************************************
 Copyright (c) Microsoft Corporation.
@@ -137,241 +361,936 @@ PERFORMANCE OF THIS SOFTWARE.
 ***************************************************************************** */
 
 function __rest(s, e) {
-    var t = {};
-    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
-        t[p] = s[p];
-    if (s != null && typeof Object.getOwnPropertySymbols === "function")
-        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
-            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
-                t[p[i]] = s[p[i]];
-        }
-    return t;
+  var t = {};
+  for (var p in s)
+    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
+      t[p] = s[p];
+  if (s != null && typeof Object.getOwnPropertySymbols === 'function')
+    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
+      if (
+        e.indexOf(p[i]) < 0 &&
+        Object.prototype.propertyIsEnumerable.call(s, p[i])
+      )
+        t[p[i]] = s[p[i]];
+    }
+  return t;
 }
 
 function __awaiter(thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
+  function adopt(value) {
+    return value instanceof P
+      ? value
+      : new P(function (resolve) {
+          resolve(value);
+        });
+  }
+  return new (P || (P = Promise))(function (resolve, reject) {
+    function fulfilled(value) {
+      try {
+        step(generator.next(value));
+      } catch (e) {
+        reject(e);
+      }
+    }
+    function rejected(value) {
+      try {
+        step(generator['throw'](value));
+      } catch (e) {
+        reject(e);
+      }
+    }
+    function step(result) {
+      result.done
+        ? resolve(result.value)
+        : adopt(result.value).then(fulfilled, rejected);
+    }
+    step((generator = generator.apply(thisArg, _arguments || [])).next());
+  });
 }
 
 const TableOfContents = (_a) => {
-    var { tableOfContents, activeId, Link, collapseTableOfContents = false, externalScrollbar, onLinkClick } = _a, boxProps = __rest(_a, ["tableOfContents", "activeId", "Link", "collapseTableOfContents", "externalScrollbar", "onLinkClick"]);
-    return (React.createElement(Flex, Object.assign({ bg: "canvas-100" }, boxProps, { flexDirection: "col", maxH: "full" }),
-        React.createElement(Flex, { flexGrow: true, flexShrink: true, overflowY: "auto" },
-            React.createElement(TableOfContents$1, { tree: tableOfContents.items, activeId: activeId, Link: Link, maxDepthOpenByDefault: collapseTableOfContents ? 0 : 1, externalScrollbar: externalScrollbar, onLinkClick: onLinkClick })),
-        tableOfContents.hide_powered_by ? null : (React.createElement(PoweredByLink, { source: activeId, pathname: typeof window !== 'undefined' ? window.location.pathname : '', packageType: "elements-dev-portal" }))));
+  var {
+      tableOfContents,
+      activeId,
+      Link,
+      collapseTableOfContents = false,
+      externalScrollbar,
+      onLinkClick,
+      page,
+    } = _a,
+    boxProps = __rest(_a, [
+      'tableOfContents',
+      'activeId',
+      'Link',
+      'collapseTableOfContents',
+      'externalScrollbar',
+      'onLinkClick',
+      'page',
+    ]);
+
+  return React.createElement(
+    Flex,
+    Object.assign({ bg: 'canvas-100' }, boxProps, {
+      flexDirection: 'col',
+      maxH: 'full',
+    }),
+    React.createElement(
+      Flex,
+      { flexGrow: true, flexShrink: true, overflowY: 'auto' },
+      React.createElement(TableOfContents$1, {
+        tree: tableOfContents.items,
+        activeId: activeId,
+        Link: Link,
+        maxDepthOpenByDefault: collapseTableOfContents ? 0 : 1,
+        externalScrollbar: externalScrollbar,
+        onLinkClick: onLinkClick,
+      })
+    ),
+    tableOfContents.hide_powered_by
+      ? null
+      : React.createElement(PoweredByLink, {
+          source: activeId,
+          pathname:
+            typeof window !== 'undefined' ? window.location.pathname : '',
+          packageType: 'elements-dev-portal',
+        })
+  );
 };
 
-const Forbidden = () => (React__default.createElement(Flex, { align: "center", justify: "center", flexGrow: true },
-    React__default.createElement(VStack, { spacing: 4, align: "center" },
-        React__default.createElement(Heading, { size: 1 }, "Forbidden"),
-        React__default.createElement(Box, { as: "p" }, "You don't have permission to access this resource"))));
+const Forbidden = () =>
+  React__default.createElement(
+    Flex,
+    { align: 'center', justify: 'center', flexGrow: true },
+    React__default.createElement(
+      VStack,
+      { spacing: 4, align: 'center' },
+      React__default.createElement(Heading, { size: 1 }, 'Forbidden'),
+      React__default.createElement(
+        Box,
+        { as: 'p' },
+        "You don't have permission to access this resource"
+      )
+    )
+  );
 
-const Loading = () => (React__default.createElement(Flex, { justify: "center", alignItems: "center", w: "full", minH: "screen", color: "muted" },
-    React__default.createElement(Icon, { icon: faCircleNotch, size: "3x", spin: true })));
+const Loading = () =>
+  React__default.createElement(
+    Flex,
+    {
+      justify: 'center',
+      alignItems: 'center',
+      w: 'full',
+      minH: 'screen',
+      color: 'muted',
+    },
+    React__default.createElement(Icon, {
+      icon: faCircleNotch,
+      size: '3x',
+      spin: true,
+    })
+  );
 
-const NotFound = () => (React__default.createElement(Flex, { align: "center", justify: "center", flexGrow: true },
-    React__default.createElement(VStack, { spacing: 4, align: "center" },
-        React__default.createElement(Heading, { size: 1 }, "Not Found"),
-        React__default.createElement(Box, { as: "p" }, "Could not find what you are looking for"))));
+const NotFound = () =>
+  React__default.createElement(
+    Flex,
+    { align: 'center', justify: 'center', flexGrow: true },
+    React__default.createElement(
+      VStack,
+      { spacing: 4, align: 'center' },
+      React__default.createElement(Heading, { size: 1 }, 'Not Found'),
+      React__default.createElement(
+        Box,
+        { as: 'p' },
+        'Could not find what you are looking for'
+      )
+    )
+  );
 
-const UpgradeToStarter = () => (React__default.createElement(Flex, { as: "a", href: "https://stoplight.io/pricing/", target: "_blank", rel: "noreferrer noopener", justify: "center", alignItems: "center", w: "full", minH: "screen", color: "muted", flexDirection: "col" },
-    React__default.createElement(Icon, { icon: faExclamationTriangle, size: "4x" }),
-    React__default.createElement(Box, { pt: 3 }, "Please upgrade your Stoplight Workspace to the Starter Plan to use Elements Dev Portal in production.")));
+const UpgradeToStarter = () =>
+  React__default.createElement(
+    Flex,
+    {
+      as: 'a',
+      href: 'https://stoplight.io/pricing/',
+      target: '_blank',
+      rel: 'noreferrer noopener',
+      justify: 'center',
+      alignItems: 'center',
+      w: 'full',
+      minH: 'screen',
+      color: 'muted',
+      flexDirection: 'col',
+    },
+    React__default.createElement(Icon, {
+      icon: faExclamationTriangle,
+      size: '4x',
+    }),
+    React__default.createElement(
+      Box,
+      { pt: 3 },
+      'Please upgrade your Stoplight Workspace to the Starter Plan to use Elements Dev Portal in production.'
+    )
+  );
 
 const appVersion = '1.4.3';
 
 class ResponseError extends Error {
-    constructor(message, responseCode) {
-        super(message);
-        this.name = 'ResponseError';
-        this.code = responseCode;
-    }
+  constructor(message, responseCode) {
+    super(message);
+    this.name = 'ResponseError';
+    this.code = responseCode;
+  }
 }
-const getNodeContent = ({ nodeSlug, projectId, branchSlug, platformUrl = 'https://stoplight.io', platformAuthToken, }) => __awaiter(void 0, void 0, void 0, function* () {
+const getNodeContent = ({
+  nodeSlug,
+  projectId,
+  branchSlug,
+  platformUrl = 'https://stoplight.io',
+  platformAuthToken,
+}) =>
+  __awaiter(void 0, void 0, void 0, function* () {
     const nodeId = getNodeIdFromSlug(nodeSlug);
     const branchQuery = branchSlug ? `?branch=${branchSlug}` : '';
-    const response = yield fetch(`${platformUrl}/api/v1/projects/${projectId}/nodes/${nodeId}${branchQuery}`, {
-        headers: Object.assign({ 'Stoplight-Elements-Version': appVersion }, (platformAuthToken && { Authorization: `Bearer ${platformAuthToken}` })),
-    });
+    const response = yield fetch(
+      `${platformUrl}/api/v1/projects/${projectId}/nodes/${nodeId}${branchQuery}`,
+      {
+        headers: Object.assign(
+          { 'Stoplight-Elements-Version': appVersion },
+          platformAuthToken && { Authorization: `Bearer ${platformAuthToken}` }
+        ),
+      }
+    );
     const data = yield response.json();
     if (!response.ok) {
-        if (response.status === 402) {
-            throw new ResponseError('Payment Required', response.status);
-        }
-        else if (response.status === 403) {
-            throw new ResponseError('Forbidden', response.status);
-        }
-        else {
-            throw new ResponseError('Something went wrong', response.status);
-        }
+      if (response.status === 402) {
+        throw new ResponseError('Payment Required', response.status);
+      } else if (response.status === 403) {
+        throw new ResponseError('Forbidden', response.status);
+      } else {
+        throw new ResponseError('Something went wrong', response.status);
+      }
     }
     return data;
-});
+  });
 function getNodeIdFromSlug(nodeSlug) {
-    return nodeSlug.split('-')[0];
+  return nodeSlug.split('-')[0];
 }
 
-const getBranches = ({ projectId, platformUrl = 'https://stoplight.io', platformAuthToken, }) => __awaiter(void 0, void 0, void 0, function* () {
-    const response = yield fetch(`${platformUrl}/api/v1/projects/${projectId}/branches`, {
-        headers: Object.assign({ 'Stoplight-Elements-Version': appVersion }, (platformAuthToken && { Authorization: `Bearer ${platformAuthToken}` })),
-    });
+const getBranches = ({
+  projectId,
+  platformUrl = 'https://stoplight.io',
+  platformAuthToken,
+}) =>
+  __awaiter(void 0, void 0, void 0, function* () {
+    const response = yield fetch(
+      `${platformUrl}/api/v1/projects/${projectId}/branches`,
+      {
+        headers: Object.assign(
+          { 'Stoplight-Elements-Version': appVersion },
+          platformAuthToken && { Authorization: `Bearer ${platformAuthToken}` }
+        ),
+      }
+    );
     const data = yield response.json();
     if (!response.ok) {
-        throw new Error(data);
+      throw new Error(data);
     }
     return data;
-});
+  });
 
 function useGetBranches({ projectId }) {
-    const { platformUrl, platformAuthToken } = React.useContext(PlatformContext);
-    return useQuery(['branches', projectId, platformUrl, platformAuthToken], () => getBranches({ projectId, platformUrl, platformAuthToken }), {
-        enabled: projectId ? true : false,
-    });
+  const { platformUrl, platformAuthToken } = React.useContext(PlatformContext);
+  return useQuery(
+    ['branches', projectId, platformUrl, platformAuthToken],
+    () => getBranches({ projectId, platformUrl, platformAuthToken }),
+    {
+      enabled: projectId ? true : false,
+    }
+  );
 }
 
-function useGetNodeContent({ nodeSlug, projectId, branchSlug, }) {
-    const { platformUrl, platformAuthToken } = React.useContext(PlatformContext);
-    return useQuery(['useNodeContent', nodeSlug, projectId, branchSlug, platformUrl, platformAuthToken], () => getNodeContent({ nodeSlug, projectId, branchSlug, platformUrl, platformAuthToken }), { enabled: nodeSlug && projectId ? true : false });
+function useGetNodeContent({ nodeSlug, projectId, branchSlug }) {
+  const { platformUrl, platformAuthToken } = React.useContext(PlatformContext);
+  return useQuery(
+    [
+      'useNodeContent',
+      nodeSlug,
+      projectId,
+      branchSlug,
+      platformUrl,
+      platformAuthToken,
+    ],
+    () =>
+      getNodeContent({
+        nodeSlug,
+        projectId,
+        branchSlug,
+        platformUrl,
+        platformAuthToken,
+      }),
+    { enabled: nodeSlug && projectId ? true : false }
+  );
 }
 
-const getTableOfContents = ({ projectId, branchSlug, platformUrl = 'https://stoplight.io', platformAuthToken, }) => __awaiter(void 0, void 0, void 0, function* () {
+const getTableOfContents = ({
+  projectId,
+  branchSlug,
+  platformUrl = 'https://stoplight.io',
+  platformAuthToken,
+}) =>
+  __awaiter(void 0, void 0, void 0, function* () {
     const branchQuery = branchSlug ? `?branch=${branchSlug}` : '';
-    const response = yield fetch(`${platformUrl}/api/v1/projects/${projectId}/table-of-contents${branchQuery}`, {
-        headers: Object.assign({ 'Stoplight-Elements-Version': appVersion }, (platformAuthToken && { Authorization: `Bearer ${platformAuthToken}` })),
-    });
+    const response = yield fetch(
+      `/api/toc`
+      // {
+      //   headers: Object.assign(
+      //     { 'Stoplight-Elements-Version': appVersion },
+      //     platformAuthToken && { Authorization: `Bearer ${platformAuthToken}` }
+      //   ),
+      // }
+    );
     const data = yield response.json();
+    console.log(data);
     if (!response.ok) {
-        throw new Error(data);
+      throw new Error(data);
     }
+
     return data;
-});
+  });
 
-function useGetTableOfContents({ projectId, branchSlug }) {
-    const { platformUrl, platformAuthToken } = React.useContext(PlatformContext);
-    return useQuery(['tableOfContents', projectId, branchSlug, platformUrl, platformAuthToken], () => getTableOfContents({ projectId, branchSlug, platformUrl, platformAuthToken }), { enabled: projectId ? true : false });
-}
+// const getTableOfContents2 = ({
+//   projectId,
+//   branchSlug,
+//   platformUrl = 'https://stoplight.io',
+//   platformAuthToken,
+//   page,
+// }) =>
+//   __awaiter(void 0, void 0, void 0, function* () {
+//     const branchQuery = branchSlug ? `?branch=${branchSlug}` : '';
+//     console.log(page);
+//     console.log(typeof page);
+//     const response = yield fetch(`/api/tags/${page}`, {
+//       headers: Object.assign(
+//         { 'Stoplight-Elements-Version': appVersion },
+//         platformAuthToken && { Authorization: `Bearer ${platformAuthToken}` }
+//       ),
+//     });
+//     const data = yield response.json();
+//     console.log(data);
 
-const StoplightProjectImpl = ({ projectId, hideTryIt, hideMocking, hideExport, collapseTableOfContents = false, tryItCredentialsPolicy, tryItCorsProxy, }) => {
-    const { branchSlug = '', nodeSlug = '' } = useParams();
-    const history = useHistory();
-    const { data: tableOfContents, isFetched: isTocFetched } = useGetTableOfContents({ projectId, branchSlug });
-    const { data: branches } = useGetBranches({ projectId });
-    const { data: node, isLoading: isLoadingNode, isError, error: nodeError, } = useGetNodeContent({
-        nodeSlug,
+//     if (!response.ok) {
+//       throw new Error(data);
+//     }
+//     return data;
+//   });
+const getTableOfContents2 = ({
+  projectId,
+  branchSlug,
+  platformUrl = 'https://stoplight.io',
+  platformAuthToken,
+  page,
+}) => {
+  // const branchQuery = branchSlug ? `?branch=${branchSlug}` : '';
+  console.log(page);
+  console.log(typeof page);
+  fetch(`/api/tags/${page}`, {
+    method: 'GET',
+    redirect: 'follow',
+  })
+    .then((response) => response.json())
+    .then((data) => {
+      if (data.items.length !== 0) {
+        console.log(data);
+        return data;
+      }
+    })
+    .catch((error) => console.log('error', error));
+  // const data = response.json();
+  // console.log(data);
+
+  // if (!response.ok) {
+  //   throw new Error(data);
+  // }
+  // return data;
+};
+
+const getItemTags = (
+  nodeId,
+  projectId,
+  platformUrl = 'https://stoplight.io',
+  platformAuthToken,
+  branchSlug
+) =>
+  __awaiter(void 0, void 0, void 0, function* () {
+    const branchQuery = branchSlug ? `?branch=${branchSlug}` : '';
+    const response = yield fetch(
+      `https://stoplight.io/api/v1/projects/${projectId}/nodes/${nodeId}${branchQuery}`,
+      {
+        headers: Object.assign(
+          { 'Stoplight-Elements-Version': appVersion },
+          platformAuthToken && {
+            Authorization: `Bearer ${platformAuthToken}`,
+          }
+        ),
+      }
+    );
+    const data = yield response.json();
+    if (!response.ok) {
+      if (response.status === 402) {
+        throw new ResponseError('Payment Required', response.status);
+      } else if (response.status === 403) {
+        throw new ResponseError('Forbidden', response.status);
+      } else {
+        throw new ResponseError('Something went wrong', response.status);
+      }
+    }
+    return data;
+  });
+
+const useGetItemTags = (toc, projectId, branchSlug) => {
+  const { platformUrl, platformAuthToken } = React.useContext(PlatformContext);
+
+  const [results, setResults] = React.useState([]);
+  const [tocCopy, setTocCopy] = React.useState({});
+
+  function queryResults() {
+    return useQueries(
+      toc.items.map((item) => {
+        return {
+          queryKey: ['item', item.id],
+          queryFn: () =>
+            getItemTags(
+              item.id,
+              projectId,
+              branchSlug,
+              platformUrl,
+              platformAuthToken
+            ),
+        };
+      }),
+      {
+        // isSuccess: console.log('success'),
+        // suspense: true,
+        onSettled: (data, error) => {
+          if (data) {
+            console.log(data);
+          } else if (error) {
+            console.log(error);
+          }
+        },
+        select: (data) => console.log(data),
+        refetchIntervalInBackground: false,
+        refetchOnWindowFocus: false,
+        refetchOnConnect: false,
+      }
+    );
+  }
+
+  console.log(queryResults());
+
+  let res = queryResults();
+  // if (
+  //   res.every((e) => {
+  //     return e.isSuccess;
+  //   })
+  // ) {
+  // setResults(res);
+  // }
+  // console.log(results);
+
+  function mappedItems() {
+    // if (
+    //   results.every((e) => {
+    //     return e.isSuccess;
+    //   })
+    // ) {
+    return toc.items.map((item) => {
+      let tags = {};
+      while (Object.keys(tags).length === 0) {
+        res.forEach((e) => {
+          if (e.data.id == item.id) {
+            tags = e.data.title;
+          }
+        });
+      }
+
+      return {
+        ...item,
+        tags,
+      };
+    });
+    // }
+  }
+
+  function tocResults() {
+    setTocCopy(toc);
+    tocCopy.items = mappedItems();
+    return tocCopy;
+  }
+
+  return tocResults();
+};
+
+function useGetTableOfContents({ projectId, branchSlug, page }) {
+  const placeholderItems = {
+    hide_powered_by: true,
+    items: [
+      {
+        title: 'apps',
+        items: [
+          {
+            id: 'ZG9jOjEyNDYxNzY',
+            title: 'BigCommerce Apps Quick Start Tutorial',
+            type: 'article',
+            slug: 'ZG9jOjEyNDYxNzY-big-commerce-apps-quick-start-tutorial',
+            meta: '',
+          },
+          {
+            id: 'ZG9jOjEyNDYxNzc',
+            title: 'Building Apps',
+            type: 'article',
+            slug: 'ZG9jOjEyNDYxNzc-building-apps',
+            meta: '',
+          },
+          {
+            title: 'guide',
+            items: [
+              {
+                id: 'ZG9jOjEyNDcxNzY',
+                title: 'Introduction to Building Apps',
+                type: 'article',
+                slug: 'ZG9jOjEyNDcxNzY-introduction-to-building-apps',
+                meta: '',
+              },
+              {
+                id: 'ZG9jOjEyNDcxNzc',
+                title: 'Types of Apps',
+                type: 'article',
+                slug: 'ZG9jOjEyNDcxNzc-types-of-apps',
+                meta: '',
+              },
+              {
+                id: 'ZG9jOjEyNDcxNzg',
+                title: 'Beginning App Development',
+                type: 'article',
+                slug: 'ZG9jOjEyNDcxNzg-beginning-app-development',
+                meta: '',
+              },
+              {
+                id: 'ZG9jOjM4MzMzNzM',
+                title: 'Managing Apps in the Developer Portal',
+                type: 'article',
+                slug: 'ZG9jOjM4MzMzNzM-managing-apps-in-the-developer-portal',
+                meta: '',
+              },
+              {
+                id: 'ZG9jOjEyNDcxODA',
+                title: 'Single-Click App OAuth Flow',
+                type: 'article',
+                slug: 'ZG9jOjEyNDcxODA-single-click-app-o-auth-flow',
+                meta: '',
+              },
+              {
+                id: 'ZG9jOjEyNDcxODE',
+                title: 'Single-Click App Callbacks',
+                type: 'article',
+                slug: 'ZG9jOjEyNDcxODE-single-click-app-callbacks',
+                meta: '',
+              },
+              {
+                id: 'ZG9jOjEyNDcxODI',
+                title: 'Supporting Multiple Users',
+                type: 'article',
+                slug: 'ZG9jOjEyNDcxODI-supporting-multiple-users',
+                meta: '',
+              },
+              {
+                id: 'ZG9jOjEyNDcxODM',
+                title: 'Listening for Events',
+                type: 'article',
+                slug: 'ZG9jOjEyNDcxODM-listening-for-events',
+                meta: '',
+              },
+              {
+                id: 'ZG9jOjEyNDcxODQ',
+                title: "Designing a Single-Click App's UI",
+                type: 'article',
+                slug: 'ZG9jOjEyNDcxODQ-designing-a-single-click-app-s-ui',
+                meta: '',
+              },
+              {
+                id: 'ZG9jOjEyNDcxODU',
+                title: 'Creating an External Installation Button',
+                type: 'article',
+                slug:
+                  'ZG9jOjEyNDcxODU-creating-an-external-installation-button',
+                meta: '',
+              },
+              {
+                id: 'ZG9jOjEyNDcxODY',
+                title: 'App Development Best Practices',
+                type: 'article',
+                slug: 'ZG9jOjEyNDcxODY-app-development-best-practices',
+                meta: '',
+              },
+              {
+                id: 'ZG9jOjEyNDcxODc',
+                title: 'App Store Approval Requirements',
+                type: 'article',
+                slug: 'ZG9jOjEyNDcxODc-app-store-approval-requirements',
+                meta: '',
+              },
+              {
+                id: 'ZG9jOjEyNDcxODg',
+                title: 'Publishing an App',
+                type: 'article',
+                slug: 'ZG9jOjEyNDcxODg-publishing-an-app',
+                meta: '',
+              },
+            ],
+          },
+          {
+            title: 'tutorials',
+            items: [
+              {
+                id: 'ZG9jOjEyNDcxODk',
+                title: "Find an App's ID",
+                type: 'article',
+                slug: 'ZG9jOjEyNDcxODk-find-an-app-s-id',
+                meta: '',
+              },
+              {
+                id: 'ZG9jOjEyNDcxOTA',
+                title: 'Building an App with Laravel and React',
+                type: 'article',
+                slug: 'ZG9jOjEyNDcxOTA-building-an-app-with-laravel-and-react',
+                meta: '',
+              },
+            ],
+          },
+        ],
+      },
+    ],
+  };
+  const { platformUrl, platformAuthToken } = React.useContext(PlatformContext);
+  console.log(page);
+  return useQuery(
+    [
+      'tableOfContents',
+      projectId,
+      branchSlug,
+      platformUrl,
+      platformAuthToken,
+      page,
+    ],
+    () =>
+      getTableOfContents2({
         projectId,
         branchSlug,
-    });
-    const container = React.useRef(null);
-    if (!nodeSlug && isTocFetched && (tableOfContents === null || tableOfContents === void 0 ? void 0 : tableOfContents.items)) {
-        const firstNode = findFirstNode(tableOfContents.items);
-        if (firstNode) {
-            return React.createElement(Redirect, { to: branchSlug ? `/branches/${branchSlug}/${firstNode.slug}` : `/${firstNode.slug}` });
-        }
-    }
-    let elem;
-    if (isLoadingNode || !isTocFetched) {
-        elem = React.createElement(Loading, null);
+        platformUrl,
+        platformAuthToken,
+        page,
+      }),
+    {
+      enabled: projectId ? true : false,
+      placeholderData: placeholderItems,
     }
-    else if (isError) {
-        if (nodeError instanceof ResponseError) {
-            if (nodeError.code === 402) {
-                elem = React.createElement(UpgradeToStarter, null);
-            }
-            else if (nodeError.code === 403) {
-                elem = React.createElement(Forbidden, null);
-            }
-            else {
-                elem = React.createElement(NotFound, null);
-            }
-        }
-        else {
-            elem = React.createElement(NotFound, null);
-        }
+  );
+}
+
+const StoplightProjectImpl = ({
+  projectId,
+  hideTryIt,
+  hideMocking,
+  hideExport,
+  collapseTableOfContents = false,
+  tryItCredentialsPolicy,
+  tryItCorsProxy,
+  page,
+}) => {
+  const { branchSlug = '', nodeSlug = '' } = useParams();
+  const history = useHistory();
+  const {
+    data: tableOfContents,
+    isFetched: isTocFetched,
+    isSuccess: isTocSuccess,
+  } = useGetTableOfContents({ projectId, branchSlug, page });
+
+  const { data: branches } = useGetBranches({ projectId });
+  const {
+    data: node,
+    isLoading: isLoadingNode,
+    isError,
+    error: nodeError,
+  } = useGetNodeContent({
+    nodeSlug,
+    projectId,
+    branchSlug,
+  });
+
+  const container = React.useRef(null);
+  if (
+    !nodeSlug &&
+    isTocFetched &&
+    (tableOfContents === null || tableOfContents === void 0
+      ? void 0
+      : tableOfContents.items)
+  ) {
+    const firstNode = findFirstNode(tableOfContents.items);
+
+    if (firstNode) {
+      return React.createElement(Redirect, {
+        to: branchSlug
+          ? `/branches/${branchSlug}/${firstNode.slug}`
+          : `/${firstNode.slug}`,
+      });
     }
-    else if (!node) {
+  }
+  let elem;
+  if (isLoadingNode || !isTocFetched) {
+    elem = React.createElement(Loading, null);
+  } else if (isError) {
+    if (nodeError instanceof ResponseError) {
+      if (nodeError.code === 402) {
+        elem = React.createElement(UpgradeToStarter, null);
+      } else if (nodeError.code === 403) {
+        elem = React.createElement(Forbidden, null);
+      } else {
         elem = React.createElement(NotFound, null);
+      }
+    } else {
+      elem = React.createElement(NotFound, null);
     }
-    else {
-        elem = (React.createElement(NodeContent, { node: node, Link: Link, hideTryIt: hideTryIt, hideMocking: hideMocking, hideExport: hideExport, tryItCredentialsPolicy: tryItCredentialsPolicy, tryItCorsProxy: tryItCorsProxy }));
+  } else if (!node) {
+    elem = React.createElement(NotFound, null);
+  } else {
+    elem = React.createElement(NodeContent, {
+      node: node,
+      Link: Link,
+      hideTryIt: hideTryIt,
+      hideMocking: hideMocking,
+      hideExport: hideExport,
+      tryItCredentialsPolicy: tryItCredentialsPolicy,
+      tryItCorsProxy: tryItCorsProxy,
+    });
+  }
+  const handleTocClick = () => {
+    if (container.current) {
+      container.current.scrollIntoView();
     }
-    const handleTocClick = () => {
-        if (container.current) {
-            container.current.scrollIntoView();
-        }
-    };
-    return (React.createElement(SidebarLayout, { ref: container, sidebar: React.createElement(React.Fragment, null,
-            branches && branches.length > 1 ? (React.createElement(BranchSelector, { branchSlug: branchSlug, branches: branches, onChange: branch => history.push(branch.is_default ? `/${nodeSlug}` : `/branches/${branch.slug}/${nodeSlug}`) })) : null,
-            tableOfContents ? (React.createElement(TableOfContents, { activeId: (node === null || node === void 0 ? void 0 : node.id) || (nodeSlug === null || nodeSlug === void 0 ? void 0 : nodeSlug.split('-')[0]) || '', tableOfContents: tableOfContents, Link: Link, collapseTableOfContents: collapseTableOfContents, onLinkClick: handleTocClick })) : null) }, elem));
+  };
+
+  return React.createElement(
+    SidebarLayout,
+    {
+      ref: container,
+      sidebar: React.createElement(
+        React.Fragment,
+        null,
+        branches && branches.length > 1
+          ? React.createElement(BranchSelector, {
+              branchSlug: branchSlug,
+              branches: branches,
+              onChange: (branch) =>
+                history.push(
+                  branch.is_default
+                    ? `/${nodeSlug}`
+                    : `/branches/${branch.slug}/${nodeSlug}`
+                ),
+            })
+          : null,
+        tableOfContents && isTocSuccess && page !== undefined
+          ? React.createElement(TableOfContents, {
+              activeId:
+                (node === null || node === void 0 ? void 0 : node.id) ||
+                (nodeSlug === null || nodeSlug === void 0
+                  ? void 0
+                  : nodeSlug.split('-')[0]) ||
+                '',
+              tableOfContents: tableOfContents,
+              Link: Link,
+              collapseTableOfContents: collapseTableOfContents,
+              onLinkClick: handleTocClick,
+              page: page,
+            })
+          : null
+      ),
+    },
+    elem
+  );
 };
 const StoplightProjectRouter = (_a) => {
-    var { platformUrl, basePath = '/', router } = _a, props = __rest(_a, ["platformUrl", "basePath", "router"]);
-    const { Router, routerProps } = useRouter(router !== null && router !== void 0 ? router : 'history', basePath);
-    return (React.createElement(DevPortalProvider, { platformUrl: platformUrl },
-        React.createElement(Router, Object.assign({}, routerProps, { key: basePath }),
-            React.createElement(Route, { path: "/branches/:branchSlug/:nodeSlug", exact: true },
-                React.createElement(StoplightProjectImpl, Object.assign({}, props))),
-            React.createElement(Route, { path: "/:nodeSlug", exact: true },
-                React.createElement(StoplightProjectImpl, Object.assign({}, props))),
-            React.createElement(Route, { path: "/", exact: true },
-                React.createElement(StoplightProjectImpl, Object.assign({}, props))))));
+  var { platformUrl, basePath = '/', router } = _a,
+    props = __rest(_a, ['platformUrl', 'basePath', 'router']);
+  const { Router, routerProps } = useRouter(
+    router !== null && router !== void 0 ? router : 'history',
+    basePath
+  );
+  return React.createElement(
+    DevPortalProvider,
+    { platformUrl: platformUrl },
+    React.createElement(
+      Router,
+      Object.assign({}, routerProps, { key: basePath }),
+      React.createElement(
+        Route,
+        { path: '/branches/:branchSlug/:nodeSlug', exact: true },
+        React.createElement(StoplightProjectImpl, Object.assign({}, props))
+      ),
+      React.createElement(
+        Route,
+        { path: '/:nodeSlug', exact: true },
+        React.createElement(StoplightProjectImpl, Object.assign({}, props))
+      ),
+      React.createElement(
+        Route,
+        { path: '/', exact: true },
+        React.createElement(StoplightProjectImpl, Object.assign({}, props))
+      )
+    )
+  );
 };
-const StoplightProject = pipe(withStyles, withPersistenceBoundary, withMosaicProvider, withQueryClientProvider)(StoplightProjectRouter);
+const StoplightProject = pipe(
+  withStyles,
+  withPersistenceBoundary,
+  withMosaicProvider,
+  withQueryClientProvider
+)(StoplightProjectRouter);
 
-const getNodes = ({ workspaceId, branchSlug, projectIds, search, platformUrl = 'https://stoplight.io', platformAuthToken, }) => __awaiter(void 0, void 0, void 0, function* () {
+const getNodes = ({
+  workspaceId,
+  branchSlug,
+  projectIds,
+  search,
+  platformUrl = 'https://stoplight.io',
+  platformAuthToken,
+}) =>
+  __awaiter(void 0, void 0, void 0, function* () {
     const queryParams = [];
     let fetchedWorkspaceId = workspaceId || '';
-    if (!workspaceId && (projectIds === null || projectIds === void 0 ? void 0 : projectIds.length)) {
-        const response = yield fetch(`${platformUrl}/api/v1/projects/${projectIds[0]}`, {
-            headers: Object.assign({ 'Stoplight-Elements-Version': appVersion }, (platformAuthToken && { Authorization: `Bearer ${platformAuthToken}` })),
-        });
-        const data = yield response.json();
-        fetchedWorkspaceId = data.workspace.id;
+    if (
+      !workspaceId &&
+      (projectIds === null || projectIds === void 0
+        ? void 0
+        : projectIds.length)
+    ) {
+      const response = yield fetch(
+        `${platformUrl}/api/v1/projects/${projectIds[0]}`,
+        {
+          headers: Object.assign(
+            { 'Stoplight-Elements-Version': appVersion },
+            platformAuthToken && {
+              Authorization: `Bearer ${platformAuthToken}`,
+            }
+          ),
+        }
+      );
+      const data = yield response.json();
+      fetchedWorkspaceId = data.workspace.id;
     }
     if (projectIds && projectIds.length) {
-        queryParams.push(...projectIds.map((projectId, index) => `project_ids[${index}]=${projectId}`));
+      queryParams.push(
+        ...projectIds.map(
+          (projectId, index) => `project_ids[${index}]=${projectId}`
+        )
+      );
     }
     if (search) {
-        queryParams.push(`search=${search}`);
+      queryParams.push(`search=${search}`);
     }
     if (branchSlug) {
-        queryParams.push(`branchSlug=${branchSlug}`);
+      queryParams.push(`branchSlug=${branchSlug}`);
     }
     const query = queryParams.length ? `?${queryParams.join('&')}` : '';
-    const response = yield fetch(`${platformUrl}/api/v1/workspaces/${fetchedWorkspaceId}/nodes${query}`, {
-        headers: Object.assign({ 'Stoplight-Elements-Version': appVersion }, (platformAuthToken && { Authorization: `Bearer ${platformAuthToken}` })),
-    });
+    const response = yield fetch(
+      `${platformUrl}/api/v1/workspaces/${fetchedWorkspaceId}/nodes${query}`,
+      {
+        headers: Object.assign(
+          { 'Stoplight-Elements-Version': appVersion },
+          platformAuthToken && { Authorization: `Bearer ${platformAuthToken}` }
+        ),
+      }
+    );
     const data = yield response.json();
     if (!response.ok) {
-        throw new Error(data);
+      throw new Error(data);
     }
     return data;
-});
+  });
 
-const getWorkspace = ({ projectIds, platformUrl = 'https://stoplight.io', platformAuthToken, }) => __awaiter(void 0, void 0, void 0, function* () {
-    const response = yield fetch(`${platformUrl}/api/v1/projects/${projectIds[0]}`, {
-        headers: Object.assign({ 'Stoplight-Elements-Version': appVersion }, (platformAuthToken && { Authorization: `Bearer ${platformAuthToken}` })),
-    });
+const getWorkspace = ({
+  projectIds,
+  platformUrl = 'https://stoplight.io',
+  platformAuthToken,
+}) =>
+  __awaiter(void 0, void 0, void 0, function* () {
+    const response = yield fetch(
+      `${platformUrl}/api/v1/projects/${projectIds[0]}`,
+      {
+        headers: Object.assign(
+          { 'Stoplight-Elements-Version': appVersion },
+          platformAuthToken && { Authorization: `Bearer ${platformAuthToken}` }
+        ),
+      }
+    );
     const data = yield response.json();
     if (!response.ok) {
-        throw new Error(data);
+      throw new Error(data);
     }
     return data;
-});
+  });
 
-function useGetNodes({ search, workspaceId, branchSlug, projectIds, pause, }) {
-    const { platformUrl, platformAuthToken } = React.useContext(PlatformContext);
-    const [debounceSearch] = useDebounce(search, 500);
-    return useQuery(['workspaceNodes', workspaceId, branchSlug, projectIds, debounceSearch, platformUrl, platformAuthToken], () => getNodes({ workspaceId, branchSlug, projectIds, search: debounceSearch, platformUrl, platformAuthToken }), { enabled: !pause });
+function useGetNodes({ search, workspaceId, branchSlug, projectIds, pause }) {
+  const { platformUrl, platformAuthToken } = React.useContext(PlatformContext);
+  const [debounceSearch] = useDebounce(search, 500);
+  return useQuery(
+    [
+      'workspaceNodes',
+      workspaceId,
+      branchSlug,
+      projectIds,
+      debounceSearch,
+      platformUrl,
+      platformAuthToken,
+    ],
+    () =>
+      getNodes({
+        workspaceId,
+        branchSlug,
+        projectIds,
+        search: debounceSearch,
+        platformUrl,
+        platformAuthToken,
+      }),
+    { enabled: !pause }
+  );
 }
 
 function useGetWorkspace({ projectIds }) {
-    const { platformUrl, platformAuthToken } = React.useContext(PlatformContext);
-    return useQuery(['useWorkspace', projectIds, platformUrl, platformAuthToken], () => getWorkspace({ projectIds, platformUrl, platformAuthToken }));
+  const { platformUrl, platformAuthToken } = React.useContext(PlatformContext);
+  return useQuery(
+    ['useWorkspace', projectIds, platformUrl, platformAuthToken],
+    () => getWorkspace({ projectIds, platformUrl, platformAuthToken })
+  );
 }
 
-export { BranchSelector, DevPortalProvider, NodeContent, ResponseError, Search, StoplightProject, TableOfContents, getBranches, getNodeContent, getNodes, getTableOfContents, getWorkspace, useGetBranches, useGetNodeContent, useGetNodes, useGetTableOfContents, useGetWorkspace };
+export {
+  BranchSelector,
+  DevPortalProvider,
+  NodeContent,
+  ResponseError,
+  Search,
+  StoplightProject,
+  TableOfContents,
+  getBranches,
+  getNodeContent,
+  getNodes,
+  getTableOfContents,
+  getTableOfContents2,
+  getWorkspace,
+  useGetBranches,
+  useGetNodeContent,
+  useGetNodes,
+  useGetTableOfContents,
+  useGetWorkspace,
+};
